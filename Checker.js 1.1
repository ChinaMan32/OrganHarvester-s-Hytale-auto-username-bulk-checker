"use strict";

const fs = require("fs");

// --- Optional notifications (won't crash if broken) ---
let notifier = null;
try {
  notifier = require("node-notifier");
} catch {
  notifier = null;
}

// ================= CONFIG =================
const CONFIG = {
  inputFile: "users.txt",
  availableFile: "available.txt",
  unavailableFile: "unavailable.txt",
  apiBaseUrl: "https://api.hystale.com/",
  concurrency: 2,

  delay: {
    safe: 1500,
    fast: 1300,
    step: 50
  },

  // Rate-limit handling
  rateLimitCooldownMs: 3000,   // what you wanted: wait 3s
  maxRetriesPerUser: 6,        // prevents infinite loops
  masked400Retries: 2,         // how many times to treat 400 as masked RL during cooldown

  // Visual separators for Available
  availableSeparator: "──────────────── AVAILABLE ────────────────"
};

// ================= COLORS =================
const C = {
  r: "\x1b[31m",
  g: "\x1b[32m",
  b: "\x1b[34m",
  y: "\x1b[33m",
  s: "\x1b[90m",
  x: "\x1b[0m"
};

const line = "════════════════════════════════════════════";
const flashFull = ">>>>>>>>>> AVAILABLE FOUND <<<<<<<<<<";
const FLASH_WIDTH = flashFull.length;

const color = (c, t) => `${c}${t}${C.x}`;
const sleep = ms => new Promise(r => setTimeout(r, ms));

// ================= HELPERS =================
const normalize = s => String(s).trim().toLowerCase();
const validUsername = s => /^[a-zA-Z0-9_]{2,32}$/.test(String(s).trim());

const read = f =>
  fs.existsSync(f)
    ? fs.readFileSync(f, "utf8").split(/\r?\n/).map(l => l.trim()).filter(Boolean)
    : [];

const append = (f, v) => fs.appendFileSync(f, v + "\n");
const setFromFile = f => new Set(read(f).map(normalize));

function pad(s, w = 16) {
  return String(s).padEnd(w, " ");
}

function centerText(text, width) {
  text = String(text);
  if (text.length >= width) return text;
  const left = Math.floor((width - text.length) / 2);
  return " ".repeat(left) + text;
}

function formatMs(ms) {
  const t = Math.floor(ms / 1000);
  return `${String(Math.floor(t / 60)).padStart(2, "0")}:${String(t % 60).padStart(2, "0")}`;
}

function isRateLimited(status, body) {
  const b = String(body || "").toLowerCase();
  return (
    status === 429 ||
    b.includes("rate") ||
    b.includes("limit") ||
    b.includes("too many") ||
    b.includes("blocked") ||
    b.includes("thrott")
  );
}

// Notifications that never crash / never spam stacks
function safeNotify(title, message) {
  if (!notifier) return;
  try {
    notifier.notify({ title, message, sound: true });
  } catch {
    // swallow
  }
}

// ================= MAIN =================
async function main() {
  // ---------- load files ----------
  const rawInput = read(CONFIG.inputFile);
  const availableSet = setFromFile(CONFIG.availableFile);
  const unavailableSet = setFromFile(CONFIG.unavailableFile);

  // ---------- pre-scan (no dupe printing, no dupe checking) ----------
  let invalid = 0, dupes = 0, alreadyChecked = 0;
  const seen = new Set();
  const queue = [];

  for (const u of rawInput) {
    if (!validUsername(u)) { invalid++; continue; }
    const k = normalize(u);
    if (seen.has(k)) { dupes++; continue; }
    seen.add(k);
    if (availableSet.has(k) || unavailableSet.has(k)) {
      alreadyChecked++; continue;
    }
    queue.push(u);
  }

  // ---------- startup banners ----------
  const est = Math.round((queue.length * CONFIG.delay.safe) / CONFIG.concurrency / 1000);

  console.log(color(C.s, line));
  console.log(color(C.r, " Made by OrganHarvester ♥"));
  console.log(color(C.s, line));
  console.log(" Input Summary");
  console.log(color(C.s, line));
  console.log(` Total lines        : ${rawInput.length}`);
  console.log(` Invalid skipped    : ${invalid}`);
  console.log(` Duplicates removed : ${dupes}`);
  console.log(` Already checked    : ${alreadyChecked}`);
  console.log(` Will check         : ${queue.length}`);
  console.log(` Estimated runtime  : ~${Math.floor(est / 60)}m ${est % 60}s`);
  console.log(color(C.s, line));

  // ---------- state ----------
  let currentDelay = CONFIG.delay.safe;

  // global pause shared by ALL workers
  let globalPauseUntil = 0;
  let lastRateLimitAt = 0;

  // retry queue fixes skipped “rate-limited words”
  const retryQueue = [];

  // retry caps per user
  const attempts = new Map(); // username(normalized) -> number

  // stats
  let countAvailable = 0;
  let countUnavailable = 0;
  let firstAvailableMs = null;
  const startTime = Date.now();

  function bumpAttempt(name) {
    const k = normalize(name);
    const v = (attempts.get(k) || 0) + 1;
    attempts.set(k, v);
    return v;
  }

  function getAttempt(name) {
    return attempts.get(normalize(name)) || 0;
  }

  function triggerGlobalCooldown() {
    lastRateLimitAt = Date.now();
    globalPauseUntil = Math.max(globalPauseUntil, lastRateLimitAt + CONFIG.rateLimitCooldownMs);
    currentDelay = CONFIG.delay.safe;
  }

  function printAvailableBlock(username) {
    console.log("");
    console.log(color(C.s, CONFIG.availableSeparator));
    console.log(color(C.g, flashFull));
    console.log(color(C.g, centerText(username, FLASH_WIDTH)));
    console.log(color(C.g, flashFull));
    console.log(color(C.s, CONFIG.availableSeparator));
    console.log("");
  }

  // ---------- worker ----------
  async function worker(workerId) {
    while (true) {
      // stop condition (both queues empty)
      if (retryQueue.length === 0 && queue.length === 0) return;

      // global cooldown check
      const now = Date.now();
      if (globalPauseUntil > now) {
        await sleep(globalPauseUntil - now);
      }

      // pull from retry first, otherwise from main queue
      const name = retryQueue.length ? retryQueue.shift() : queue.shift();
      if (!name) continue;

      const display = pad(name);

      try {
        const res = await fetch(`${CONFIG.apiBaseUrl}?username=${encodeURIComponent(name)}`, {
          headers: { "User-Agent": "Mozilla/5.0", "Accept": "*/*" }
        });

        const body = await res.text().catch(() => "");

        // ---- HARD rate limit detection ----
        if (isRateLimited(res.status, body)) {
          console.log(color(C.y, `${display} > Rate Limited`));

          const n = bumpAttempt(name);
          if (n <= CONFIG.maxRetriesPerUser) {
            triggerGlobalCooldown();
            retryQueue.push(name);
            safeNotify("Hystale Checker", `Rate limited — cooling down ${CONFIG.rateLimitCooldownMs / 1000}s`);
          } else {
            // give up after too many RL hits
            console.log(color(C.r, `${display} > Unavailable > 400`));
            append(CONFIG.unavailableFile, name);
            unavailableSet.add(normalize(name));
            countUnavailable++;
          }
          continue;
        }

        // ---- MASKED 400 handling ----
        // If we recently rate-limited and are effectively still in that window,
        // treat some 400s as throttle fallout and retry (limited times).
        const inRlWindow = (Date.now() - lastRateLimitAt) < (CONFIG.rateLimitCooldownMs * 2);

        if (res.status === 400 && inRlWindow && getAttempt(name) < CONFIG.masked400Retries) {
          console.log(color(C.y, `${display} > Rate Limited`));
          bumpAttempt(name);
          triggerGlobalCooldown();
          retryQueue.push(name);
          continue;
        }

        // ---- normal classification ----
        if (res.status === 200) {
          printAvailableBlock(name);

          append(CONFIG.availableFile, name);
          availableSet.add(normalize(name));
          countAvailable++;

          if (firstAvailableMs === null) {
            firstAvailableMs = Date.now() - startTime;
          }

          safeNotify("Username Available!", name);

          // move toward fast
          currentDelay = Math.max(CONFIG.delay.fast, currentDelay - CONFIG.delay.step);
        } else if (res.status === 400) {
          console.log(color(C.r, `${display} > Unavailable > 400`));
          append(CONFIG.unavailableFile, name);
          unavailableSet.add(normalize(name));
          countUnavailable++;

          // drift toward safe
          currentDelay = Math.min(CONFIG.delay.safe, currentDelay + CONFIG.delay.step);
        } else {
          console.log(color(C.r, `${display} > Unavailable > ${res.status}`));
          append(CONFIG.unavailableFile, name);
          unavailableSet.add(normalize(name));
          countUnavailable++;

          currentDelay = Math.min(CONFIG.delay.safe, currentDelay + CONFIG.delay.step);
        }
      } catch {
        // network error: retry but cap it
        const n = bumpAttempt(name);
        currentDelay = Math.min(CONFIG.delay.safe, currentDelay + CONFIG.delay.step);

        if (n <= CONFIG.maxRetriesPerUser) {
          retryQueue.push(name);
        } else {
          console.log(color(C.r, `${display} > Unavailable > 400`));
          append(CONFIG.unavailableFile, name);
          unavailableSet.add(normalize(name));
          countUnavailable++;
        }
      }

      await sleep(currentDelay);
    }
  }

  // ---------- run ----------
  await Promise.all(Array(CONFIG.concurrency).fill(0).map((_, i) => worker(i)));

  // ---------- summary ----------
  console.log("\n" + color(C.s, line));
  console.log(" SUMMARY");
  console.log(color(C.s, line));
  console.log(color(C.g, ` Available   : ${countAvailable}`));
  console.log(color(C.r, ` Unavailable : ${countUnavailable}`));
  console.log(color(C.s, ` First Available After : ${firstAvailableMs === null ? "Not found" : formatMs(firstAvailableMs)}`));
  console.log(color(C.s, line));
  console.log(color(C.s, " Finished"));
  console.log(color(C.s, line));

  safeNotify("Hystale Checker", "Finished checking usernames");
}

main().catch(err => {
  console.error("Fatal error:", err);
  process.exit(1);
});
